#!/bin/bash
{%- if SCHEDULER_NAME == "pbs" %}
#PBS -N {{ NAME }}
#PBS -l select={{ NUM_PROCS }}:mpiprocs=1:ncpus={{ NUM_THREADS }}
#PBS -l walltime={{ WALLTIME }}
#PBS -P {{ PROJECT }}
{%- if HOLD is defined %}
#PBS -h
{%- endif %}
{%- if QUEUE is defined %}
#PBS -q {{ QUEUE }}
{%- endif %}
#PBS -j oe
#PBS -o {{ OUTPUT }}
#PBS -l place={{ PLACE }}
{%- elif SCHEDULER_NAME == "slurm" %}
#SBATCH --job-name={{ NAME }}
#SBATCH --ntasks={{ NUM_PROCS }}
#SBATCH --cpus-per-task={{ NUM_THREADS }}
#SBATCH --time={{ WALLTIME }}
#SBATCH --wckey={{ PROJECT }}
#SBATCH --output={{ OUTPUT }}
{%- if HOLD is defined %}
#SBATCH --hold
{%- endif %}
{%- if PLACE == "scatter" %}
#SBATCH --ntasks-per-node=1
{%- endif %}
{%- endif %}

# Exit on failure
set -e

{%- if SOURCE_FILE is defined %}
# Loaded from {{ SOURCE_FILE }}
{{ SOURCE_CONTENTS }}
{%- endif %}

{%- if NUM_THREADS != 1 %}
# Set mvapich options for threading
export MV2_USE_ALIGNED_ALLOC=1
export MV2_THREADS_PER_PROCESS={{ NUM_THREADS }}
{%- endif %}

# Add MOOSE's python path for python scripts
export PYTHONPATH={{ MOOSE_PYTHONPATH }}:${PYTHONPATH}

# Print a useful header
echo "TestHarness {{ SCHEDULER_NAME }} job on $(hostname) in job ${{ JOB_ID_VARIABLE }}"
echo "Time: $(date)"
echo 'Test: {{ TEST_SPEC }}:{{ TEST_NAME }}'
echo 'Directory: {{ CWD }}'
echo 'Submitted hostname: {{ SUBMITTED_HOSTNAME }}'
echo 'Submission script: {{ SUBMISSION_SCRIPT }}'
echo 'Output: {{ OUTPUT }}'
module list

echo "################################################################################"
echo "Beginning TestHarness {{ SCHEDULER_NAME }} test execution"

# Move into the test directory
cd {{ CWD }}

# Don't exit on failure: need to capture the actual run's return code
set +e

# Run the command
{{ COMMAND }}
# ...and capture the return code cause we're not done yet
return_code=$?

# Exit on failure
set -e

# We will read this output later on to try to capture the return code
# in the event that PBS doesn't get it to us correctly
echo "################################################################################"
{%- if USING_APPTAINER is defined %}
# We have a special case with exit codes when we run within apptainer. Sometimes when
# codes are received when running in a container, the container will return with exit code
# 128 + <code>. Capture that here because we don't wanna exit code a code > 128, which
# are special exit codes for the schedulers.
if ((return_code > 128)); then
    new_return_code=$((return_code - 128))
    echo "Apptainer exited with code $return_code, using $new_return_code instead"
    return_code=$new_return_code
fi
{%- endif %}
echo "Completed TestHarness {{ SCHEDULER_NAME }} test execution; exit code = $return_code"

# Append a terminator to all of the output files for file syncing across NFS
ADDITIONAL_OUTPUT_FILES=({{ ADDITIONAL_OUTPUT_FILES }})
for file in ${ADDITIONAL_OUTPUT_FILES[@]}; do
    if [ ! -e "$file" ]; then
        echo "Failed to finalize output $file"
        continue
    fi

    # No newline for binaries
    if [[ $(file --mime-encoding ${file}) = *binary ]]; then
        printf "{{ ENDING_COMMENT }}" >> $file;
    # Newline for plain text
    else
        printf "\n{{ ENDING_COMMENT }}" >> $file;
    fi
    echo "Finalized output $file"
done

# Append a recognizable string at the end of the output. We look
# for this string when parsing the output so that we can be sure
# that we have obtained all of the output
printf "\n{{ ENDING_COMMENT }}"

# Exit with the real return code from the job that we ran
exit $return_code

